"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.cameraWorldMatrix = exports.cameraNormalMatrix = exports.cameraViewMatrix = exports.cameraProjectionMatrix = exports.storage = exports.buffer = exports.vary = exports.temp = exports.label = exports.instanceIndex = exports.call = exports.expression = exports.context = exports.code = exports.bypass = exports.property = exports.attribute = exports.uniform = exports.func = exports.bmat4 = exports.umat4 = exports.imat4 = exports.mat4 = exports.bmat3 = exports.umat3 = exports.imat3 = exports.mat3 = exports.bvec4 = exports.uvec4 = exports.ivec4 = exports.vec4 = exports.bvec3 = exports.uvec3 = exports.ivec3 = exports.vec3 = exports.bvec2 = exports.uvec2 = exports.ivec2 = exports.vec2 = exports.bool = exports.uint = exports.int = exports.float = exports.color = exports.nodeImmutable = exports.nodeProxy = exports.nodeArray = exports.nodeObjects = exports.nodeObject = exports.ShaderNode = void 0;
exports.and = exports.greaterThanEqual = exports.lessThanEqual = exports.greaterThan = exports.lessThan = exports.assign = exports.equal = exports.remainder = exports.div = exports.mul = exports.sub = exports.add = exports.cond = exports.INFINITY = exports.EPSILON = exports.compute = exports.pointUV = exports.uv = exports.sampler = exports.texture = exports.positionViewDirection = exports.positionView = exports.positionWorld = exports.positionLocal = exports.positionGeometry = exports.modelViewPosition = exports.modelPosition = exports.modelWorldMatrix = exports.modelNormalMatrix = exports.modelViewMatrix = exports.transformedNormalView = exports.normalView = exports.normalWorld = exports.normalLocal = exports.normalGeometry = exports.modelViewProjection = exports.materialReference = exports.reference = exports.specularColor = exports.alphaTest = exports.metalness = exports.roughness = exports.diffuseColor = exports.materialMetalness = exports.materialRoughness = exports.materialOpacity = exports.materialEmissive = exports.materialColor = exports.materialAlphaTest = exports.cameraPosition = void 0;
exports.refract = exports.clamp = exports.mix = exports.transformDirection = exports.pow4 = exports.pow3 = exports.pow2 = exports.pow = exports.cross = exports.dot = exports.distance = exports.reflect = exports.step = exports.mod = exports.max = exports.min = exports.round = exports.saturate = exports.dFdy = exports.dFdx = exports.invert = exports.negate = exports.length = exports.sign = exports.abs = exports.atan = exports.acos = exports.asin = exports.tan = exports.cos = exports.sin = exports.fract = exports.normalize = exports.ceil = exports.floor = exports.inversesqrt = exports.sqrt = exports.log2 = exports.log = exports.exp2 = exports.exp = exports.degrees = exports.radians = exports.shiftRight = exports.shiftLeft = exports.bitXor = exports.bitOr = exports.bitAnd = exports.xor = exports.or = void 0;
exports.transformedNormalWorld = exports.dotNV = exports.element = exports.faceDirection = exports.frontFacing = exports.faceforward = exports.smoothstep = void 0;
// core
//import ArrayUniformNode from '../core/ArrayUniformNode';
const AttributeNode_1 = __importDefault(require("../core/AttributeNode"));
const BypassNode_1 = __importDefault(require("../core/BypassNode"));
const CodeNode_1 = __importDefault(require("../core/CodeNode"));
const ContextNode_1 = __importDefault(require("../core/ContextNode"));
const ExpressionNode_1 = __importDefault(require("../core/ExpressionNode"));
const FunctionCallNode_1 = __importDefault(require("../core/FunctionCallNode"));
const FunctionNode_1 = __importDefault(require("../core/FunctionNode"));
const InstanceIndexNode_1 = __importDefault(require("../core/InstanceIndexNode"));
const PropertyNode_1 = __importDefault(require("../core/PropertyNode"));
const UniformNode_1 = __importDefault(require("../core/UniformNode"));
const VarNode_1 = __importDefault(require("../core/VarNode"));
const VaryNode_1 = __importDefault(require("../core/VaryNode"));
// accessors
const BufferNode_1 = __importDefault(require("../accessors/BufferNode"));
const CameraNode_1 = __importDefault(require("../accessors/CameraNode"));
const MaterialNode_1 = __importDefault(require("../accessors/MaterialNode"));
const MaterialReferenceNode_1 = __importDefault(require("../accessors/MaterialReferenceNode"));
const ModelViewProjectionNode_1 = __importDefault(require("../accessors/ModelViewProjectionNode"));
const NormalNode_1 = __importDefault(require("../accessors/NormalNode"));
const ModelNode_1 = __importDefault(require("../accessors/ModelNode"));
const PointUVNode_1 = __importDefault(require("../accessors/PointUVNode"));
const PositionNode_1 = __importDefault(require("../accessors/PositionNode"));
const ReferenceNode_1 = __importDefault(require("../accessors/ReferenceNode"));
const StorageBufferNode_1 = __importDefault(require("../accessors/StorageBufferNode"));
const TextureNode_1 = __importDefault(require("../accessors/TextureNode"));
const UVNode_1 = __importDefault(require("../accessors/UVNode"));
// display
const FrontFacingNode_1 = __importDefault(require("../display/FrontFacingNode"));
// gpgpu
const ComputeNode_1 = __importDefault(require("../gpgpu/ComputeNode"));
// math
const MathNode_1 = __importDefault(require("../math/MathNode"));
const OperatorNode_1 = __importDefault(require("../math/OperatorNode"));
const CondNode_1 = __importDefault(require("../math/CondNode"));
// utils
const ArrayElementNode_1 = __importDefault(require("../utils/ArrayElementNode"));
const ConvertNode_1 = __importDefault(require("../utils/ConvertNode"));
// shader node utils
const ShaderNode_1 = require("./ShaderNode");
Object.defineProperty(exports, "ShaderNode", { enumerable: true, get: function () { return ShaderNode_1.ShaderNode; } });
Object.defineProperty(exports, "nodeObject", { enumerable: true, get: function () { return ShaderNode_1.nodeObject; } });
Object.defineProperty(exports, "nodeObjects", { enumerable: true, get: function () { return ShaderNode_1.nodeObjects; } });
Object.defineProperty(exports, "nodeArray", { enumerable: true, get: function () { return ShaderNode_1.nodeArray; } });
Object.defineProperty(exports, "nodeProxy", { enumerable: true, get: function () { return ShaderNode_1.nodeProxy; } });
Object.defineProperty(exports, "nodeImmutable", { enumerable: true, get: function () { return ShaderNode_1.nodeImmutable; } });
exports.color = new ShaderNode_1.ConvertType('color');
exports.float = new ShaderNode_1.ConvertType('float', ShaderNode_1.cacheMaps.float);
exports.int = new ShaderNode_1.ConvertType('int', ShaderNode_1.cacheMaps.int);
exports.uint = new ShaderNode_1.ConvertType('uint', ShaderNode_1.cacheMaps.uint);
exports.bool = new ShaderNode_1.ConvertType('bool', ShaderNode_1.cacheMaps.bool);
exports.vec2 = new ShaderNode_1.ConvertType('vec2');
exports.ivec2 = new ShaderNode_1.ConvertType('ivec2');
exports.uvec2 = new ShaderNode_1.ConvertType('uvec2');
exports.bvec2 = new ShaderNode_1.ConvertType('bvec2');
exports.vec3 = new ShaderNode_1.ConvertType('vec3');
exports.ivec3 = new ShaderNode_1.ConvertType('ivec3');
exports.uvec3 = new ShaderNode_1.ConvertType('uvec3');
exports.bvec3 = new ShaderNode_1.ConvertType('bvec3');
exports.vec4 = new ShaderNode_1.ConvertType('vec4');
exports.ivec4 = new ShaderNode_1.ConvertType('ivec4');
exports.uvec4 = new ShaderNode_1.ConvertType('uvec4');
exports.bvec4 = new ShaderNode_1.ConvertType('bvec4');
exports.mat3 = new ShaderNode_1.ConvertType('mat3');
exports.imat3 = new ShaderNode_1.ConvertType('imat3');
exports.umat3 = new ShaderNode_1.ConvertType('umat3');
exports.bmat3 = new ShaderNode_1.ConvertType('bmat3');
exports.mat4 = new ShaderNode_1.ConvertType('mat4');
exports.imat4 = new ShaderNode_1.ConvertType('imat4');
exports.umat4 = new ShaderNode_1.ConvertType('umat4');
exports.bmat4 = new ShaderNode_1.ConvertType('bmat4');
// core
// @TODO: ArrayUniformNode
const func = (code) => {
    const node = ShaderNode_1.nodeObject(new FunctionNode_1.default(code));
    const call = node.call.bind(node);
    node.call = (params) => ShaderNode_1.nodeObject(call(params));
    return node;
};
exports.func = func;
const uniform = (nodeOrType) => {
    var _a;
    const nodeType = ShaderNode_1.getConstNodeType(nodeOrType);
    // @TODO: get ConstNode from .traverse() in the future
    const value = nodeOrType.isNode === true ? ((_a = nodeOrType.node) === null || _a === void 0 ? void 0 : _a.value) || nodeOrType.value : nodeOrType;
    return ShaderNode_1.nodeObject(new UniformNode_1.default(value, nodeType));
};
exports.uniform = uniform;
const attribute = (name, nodeType) => ShaderNode_1.nodeObject(new AttributeNode_1.default(name, nodeType));
exports.attribute = attribute;
const property = (name, nodeOrType) => ShaderNode_1.nodeObject(new PropertyNode_1.default(name, ShaderNode_1.getConstNodeType(nodeOrType)));
exports.property = property;
exports.bypass = ShaderNode_1.nodeProxy(BypassNode_1.default);
exports.code = ShaderNode_1.nodeProxy(CodeNode_1.default);
exports.context = ShaderNode_1.nodeProxy(ContextNode_1.default);
exports.expression = ShaderNode_1.nodeProxy(ExpressionNode_1.default);
exports.call = ShaderNode_1.nodeProxy(FunctionCallNode_1.default);
exports.instanceIndex = ShaderNode_1.nodeImmutable(InstanceIndexNode_1.default);
exports.label = ShaderNode_1.nodeProxy(VarNode_1.default);
exports.temp = exports.label;
exports.vary = ShaderNode_1.nodeProxy(VaryNode_1.default);
// accesors
const buffer = (value, nodeOrType, count) => ShaderNode_1.nodeObject(new BufferNode_1.default(value, ShaderNode_1.getConstNodeType(nodeOrType), count));
exports.buffer = buffer;
const storage = (value, nodeOrType, count) => ShaderNode_1.nodeObject(new StorageBufferNode_1.default(value, ShaderNode_1.getConstNodeType(nodeOrType), count));
exports.storage = storage;
exports.cameraProjectionMatrix = ShaderNode_1.nodeImmutable(CameraNode_1.default, CameraNode_1.default.PROJECTION_MATRIX);
exports.cameraViewMatrix = ShaderNode_1.nodeImmutable(CameraNode_1.default, CameraNode_1.default.VIEW_MATRIX);
exports.cameraNormalMatrix = ShaderNode_1.nodeImmutable(CameraNode_1.default, CameraNode_1.default.NORMAL_MATRIX);
exports.cameraWorldMatrix = ShaderNode_1.nodeImmutable(CameraNode_1.default, CameraNode_1.default.WORLD_MATRIX);
exports.cameraPosition = ShaderNode_1.nodeImmutable(CameraNode_1.default, CameraNode_1.default.POSITION);
exports.materialAlphaTest = ShaderNode_1.nodeImmutable(MaterialNode_1.default, MaterialNode_1.default.ALPHA_TEST);
exports.materialColor = ShaderNode_1.nodeImmutable(MaterialNode_1.default, MaterialNode_1.default.COLOR);
exports.materialEmissive = ShaderNode_1.nodeImmutable(MaterialNode_1.default, MaterialNode_1.default.EMISSIVE);
exports.materialOpacity = ShaderNode_1.nodeImmutable(MaterialNode_1.default, MaterialNode_1.default.OPACITY);
//export const materialSpecular = nodeImmutable( MaterialNode, MaterialNode.SPECULAR );
exports.materialRoughness = ShaderNode_1.nodeImmutable(MaterialNode_1.default, MaterialNode_1.default.ROUGHNESS);
exports.materialMetalness = ShaderNode_1.nodeImmutable(MaterialNode_1.default, MaterialNode_1.default.METALNESS);
exports.diffuseColor = ShaderNode_1.nodeImmutable(PropertyNode_1.default, 'DiffuseColor', 'vec4');
exports.roughness = ShaderNode_1.nodeImmutable(PropertyNode_1.default, 'Roughness', 'float');
exports.metalness = ShaderNode_1.nodeImmutable(PropertyNode_1.default, 'Metalness', 'float');
exports.alphaTest = ShaderNode_1.nodeImmutable(PropertyNode_1.default, 'AlphaTest', 'float');
exports.specularColor = ShaderNode_1.nodeImmutable(PropertyNode_1.default, 'SpecularColor', 'color');
const reference = (name, nodeOrType, object) => ShaderNode_1.nodeObject(new ReferenceNode_1.default(name, ShaderNode_1.getConstNodeType(nodeOrType), object));
exports.reference = reference;
const materialReference = (name, nodeOrType, material) => ShaderNode_1.nodeObject(new MaterialReferenceNode_1.default(name, ShaderNode_1.getConstNodeType(nodeOrType), material));
exports.materialReference = materialReference;
exports.modelViewProjection = ShaderNode_1.nodeProxy(ModelViewProjectionNode_1.default);
exports.normalGeometry = ShaderNode_1.nodeImmutable(NormalNode_1.default, NormalNode_1.default.GEOMETRY);
exports.normalLocal = ShaderNode_1.nodeImmutable(NormalNode_1.default, NormalNode_1.default.LOCAL);
exports.normalWorld = ShaderNode_1.nodeImmutable(NormalNode_1.default, NormalNode_1.default.WORLD);
exports.normalView = ShaderNode_1.nodeImmutable(NormalNode_1.default, NormalNode_1.default.VIEW);
exports.transformedNormalView = ShaderNode_1.nodeImmutable(VarNode_1.default, exports.normalView, 'TransformedNormalView');
exports.modelViewMatrix = ShaderNode_1.nodeImmutable(ModelNode_1.default, ModelNode_1.default.VIEW_MATRIX);
exports.modelNormalMatrix = ShaderNode_1.nodeImmutable(ModelNode_1.default, ModelNode_1.default.NORMAL_MATRIX);
exports.modelWorldMatrix = ShaderNode_1.nodeImmutable(ModelNode_1.default, ModelNode_1.default.WORLD_MATRIX);
exports.modelPosition = ShaderNode_1.nodeImmutable(ModelNode_1.default, ModelNode_1.default.POSITION);
exports.modelViewPosition = ShaderNode_1.nodeImmutable(ModelNode_1.default, ModelNode_1.default.VIEW_POSITION);
exports.positionGeometry = ShaderNode_1.nodeImmutable(PositionNode_1.default, PositionNode_1.default.GEOMETRY);
exports.positionLocal = ShaderNode_1.nodeImmutable(PositionNode_1.default, PositionNode_1.default.LOCAL);
exports.positionWorld = ShaderNode_1.nodeImmutable(PositionNode_1.default, PositionNode_1.default.WORLD);
exports.positionView = ShaderNode_1.nodeImmutable(PositionNode_1.default, PositionNode_1.default.VIEW);
exports.positionViewDirection = ShaderNode_1.nodeImmutable(PositionNode_1.default, PositionNode_1.default.VIEW_DIRECTION);
exports.texture = ShaderNode_1.nodeProxy(TextureNode_1.default);
const sampler = (texture) => ShaderNode_1.nodeObject(new ConvertNode_1.default(texture.isNode === true ? texture : new TextureNode_1.default(texture), 'sampler'));
exports.sampler = sampler;
const uv = (...params) => ShaderNode_1.nodeObject(new UVNode_1.default(...params));
exports.uv = uv;
exports.pointUV = ShaderNode_1.nodeImmutable(PointUVNode_1.default);
// gpgpu
const compute = (node, count, workgroupSize) => ShaderNode_1.nodeObject(new ComputeNode_1.default(ShaderNode_1.nodeObject(node), count, workgroupSize));
exports.compute = compute;
// math
exports.EPSILON = exports.float(1e-6);
exports.INFINITY = exports.float(1e6);
exports.cond = ShaderNode_1.nodeProxy(CondNode_1.default);
exports.add = ShaderNode_1.nodeProxy(OperatorNode_1.default, '+');
exports.sub = ShaderNode_1.nodeProxy(OperatorNode_1.default, '-');
exports.mul = ShaderNode_1.nodeProxy(OperatorNode_1.default, '*');
exports.div = ShaderNode_1.nodeProxy(OperatorNode_1.default, '/');
exports.remainder = ShaderNode_1.nodeProxy(OperatorNode_1.default, '%');
exports.equal = ShaderNode_1.nodeProxy(OperatorNode_1.default, '==');
exports.assign = ShaderNode_1.nodeProxy(OperatorNode_1.default, '=');
exports.lessThan = ShaderNode_1.nodeProxy(OperatorNode_1.default, '<');
exports.greaterThan = ShaderNode_1.nodeProxy(OperatorNode_1.default, '>');
exports.lessThanEqual = ShaderNode_1.nodeProxy(OperatorNode_1.default, '<=');
exports.greaterThanEqual = ShaderNode_1.nodeProxy(OperatorNode_1.default, '>=');
exports.and = ShaderNode_1.nodeProxy(OperatorNode_1.default, '&&');
exports.or = ShaderNode_1.nodeProxy(OperatorNode_1.default, '||');
exports.xor = ShaderNode_1.nodeProxy(OperatorNode_1.default, '^^');
exports.bitAnd = ShaderNode_1.nodeProxy(OperatorNode_1.default, '&');
exports.bitOr = ShaderNode_1.nodeProxy(OperatorNode_1.default, '|');
exports.bitXor = ShaderNode_1.nodeProxy(OperatorNode_1.default, '^');
exports.shiftLeft = ShaderNode_1.nodeProxy(OperatorNode_1.default, '<<');
exports.shiftRight = ShaderNode_1.nodeProxy(OperatorNode_1.default, '>>');
exports.radians = ShaderNode_1.nodeProxy(MathNode_1.default, MathNode_1.default.RADIANS);
exports.degrees = ShaderNode_1.nodeProxy(MathNode_1.default, MathNode_1.default.DEGREES);
exports.exp = ShaderNode_1.nodeProxy(MathNode_1.default, MathNode_1.default.EXP);
exports.exp2 = ShaderNode_1.nodeProxy(MathNode_1.default, MathNode_1.default.EXP2);
exports.log = ShaderNode_1.nodeProxy(MathNode_1.default, MathNode_1.default.LOG);
exports.log2 = ShaderNode_1.nodeProxy(MathNode_1.default, MathNode_1.default.LOG2);
exports.sqrt = ShaderNode_1.nodeProxy(MathNode_1.default, MathNode_1.default.SQRT);
exports.inversesqrt = ShaderNode_1.nodeProxy(MathNode_1.default, MathNode_1.default.INVERSE_SQRT);
exports.floor = ShaderNode_1.nodeProxy(MathNode_1.default, MathNode_1.default.FLOOR);
exports.ceil = ShaderNode_1.nodeProxy(MathNode_1.default, MathNode_1.default.CEIL);
exports.normalize = ShaderNode_1.nodeProxy(MathNode_1.default, MathNode_1.default.NORMALIZE);
exports.fract = ShaderNode_1.nodeProxy(MathNode_1.default, MathNode_1.default.FRACT);
exports.sin = ShaderNode_1.nodeProxy(MathNode_1.default, MathNode_1.default.SIN);
exports.cos = ShaderNode_1.nodeProxy(MathNode_1.default, MathNode_1.default.COS);
exports.tan = ShaderNode_1.nodeProxy(MathNode_1.default, MathNode_1.default.TAN);
exports.asin = ShaderNode_1.nodeProxy(MathNode_1.default, MathNode_1.default.ASIN);
exports.acos = ShaderNode_1.nodeProxy(MathNode_1.default, MathNode_1.default.ACOS);
exports.atan = ShaderNode_1.nodeProxy(MathNode_1.default, MathNode_1.default.ATAN);
exports.abs = ShaderNode_1.nodeProxy(MathNode_1.default, MathNode_1.default.ABS);
exports.sign = ShaderNode_1.nodeProxy(MathNode_1.default, MathNode_1.default.SIGN);
exports.length = ShaderNode_1.nodeProxy(MathNode_1.default, MathNode_1.default.LENGTH);
exports.negate = ShaderNode_1.nodeProxy(MathNode_1.default, MathNode_1.default.NEGATE);
exports.invert = ShaderNode_1.nodeProxy(MathNode_1.default, MathNode_1.default.INVERT);
exports.dFdx = ShaderNode_1.nodeProxy(MathNode_1.default, MathNode_1.default.DFDX);
exports.dFdy = ShaderNode_1.nodeProxy(MathNode_1.default, MathNode_1.default.DFDY);
exports.saturate = ShaderNode_1.nodeProxy(MathNode_1.default, MathNode_1.default.SATURATE);
exports.round = ShaderNode_1.nodeProxy(MathNode_1.default, MathNode_1.default.ROUND);
exports.min = ShaderNode_1.nodeProxy(MathNode_1.default, MathNode_1.default.MIN);
exports.max = ShaderNode_1.nodeProxy(MathNode_1.default, MathNode_1.default.MAX);
exports.mod = ShaderNode_1.nodeProxy(MathNode_1.default, MathNode_1.default.MOD);
exports.step = ShaderNode_1.nodeProxy(MathNode_1.default, MathNode_1.default.STEP);
exports.reflect = ShaderNode_1.nodeProxy(MathNode_1.default, MathNode_1.default.REFLECT);
exports.distance = ShaderNode_1.nodeProxy(MathNode_1.default, MathNode_1.default.DISTANCE);
exports.dot = ShaderNode_1.nodeProxy(MathNode_1.default, MathNode_1.default.DOT);
exports.cross = ShaderNode_1.nodeProxy(MathNode_1.default, MathNode_1.default.CROSS);
exports.pow = ShaderNode_1.nodeProxy(MathNode_1.default, MathNode_1.default.POW);
exports.pow2 = ShaderNode_1.nodeProxy(MathNode_1.default, MathNode_1.default.POW, 2);
exports.pow3 = ShaderNode_1.nodeProxy(MathNode_1.default, MathNode_1.default.POW, 3);
exports.pow4 = ShaderNode_1.nodeProxy(MathNode_1.default, MathNode_1.default.POW, 4);
exports.transformDirection = ShaderNode_1.nodeProxy(MathNode_1.default, MathNode_1.default.TRANSFORM_DIRECTION);
exports.mix = ShaderNode_1.nodeProxy(MathNode_1.default, MathNode_1.default.MIX);
exports.clamp = ShaderNode_1.nodeProxy(MathNode_1.default, MathNode_1.default.CLAMP);
exports.refract = ShaderNode_1.nodeProxy(MathNode_1.default, MathNode_1.default.REFRACT);
exports.smoothstep = ShaderNode_1.nodeProxy(MathNode_1.default, MathNode_1.default.SMOOTHSTEP);
exports.faceforward = ShaderNode_1.nodeProxy(MathNode_1.default, MathNode_1.default.FACEFORWARD);
// display
exports.frontFacing = ShaderNode_1.nodeImmutable(FrontFacingNode_1.default);
exports.faceDirection = exports.sub(exports.mul(exports.float(exports.frontFacing), 2), 1);
// lighting
// utils
exports.element = ShaderNode_1.nodeProxy(ArrayElementNode_1.default);
// miscellaneous
exports.dotNV = exports.saturate(exports.dot(exports.transformedNormalView, exports.positionViewDirection));
exports.transformedNormalWorld = exports.normalize(exports.transformDirection(exports.transformedNormalView, exports.cameraViewMatrix));
